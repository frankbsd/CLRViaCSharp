第二部分
第四章	类型基础
第五章	基元类型、引用类型和值类型
第六章	类型和成员基础
第七章	常量和字段
第八章	方法
第九章	参数
第十章	属性
第十一章	事件
第十二章	泛型
第十三章	接口


第四章	类型基础
4.1	所有类型都从System.Object派生
	“运行时”要求每个类型最终都以System.Object类型派生。
	所以，每个类型都有System.Object提供的公共实例方法：
														Equals、
														GetHashCode、
														ToString（默认返回类型的完整名称:this.GetType().FullName)、
														GetType(非虚方法，防止类重写该方法，隐瞒其类型，进而破坏类型安全性)
	还有从System.Object派生的类型受保护方法：
											MemberwiseClone、
											Finalize
	CLR要求所有对象都用new操作符创建。
		Employee e=new Employee("ConstructorParam")
	new操作符所做的事情有：
		1、计算类型及其所有基类型中定义的所有实例字段需要的字节数。
		   堆上每个对象都需要一些额外的成员（overhead成员，或者说“开销成员”），包括“类型对象指针”（type object pointer）和“同步块索引”（Sync block index）。
		   CLR利用这些成员管理对象。额外成员的字节数要计入对象大小。
		2、从托管堆上分配类型要求的字节数，从而分配对象的内存，分配的所有字节都设为0。
		3、初始化对象的“类型对象指针”和“同步块索引”成员。
		4、调用类型的实例构造器，传递在new调用中指定的实参。
		   大多数编译器都在构造器中自动生成代码来调用基类构造器。
		   每个类型的构造器都负责初始化该类型定义的实例字段。
		   最终调用System.Object的构造器，该构造器什么都不做，简单的返回。
	new执行了所有这些操作之后，返回指向新建对象一个引用（或指针）。在上面的示例代码中，该引用保存到变量e中，后者具有Employee类型。
	注意：没有和new操作符对应的删除操作符；
		  换言之，没有办法显示释放为对象分配的内存。CLR采用了垃圾回收机制，能自动检测到一个对象不再被使用或访问，并自动释放对象的内存。

4.2	类型转换
	CLR最重要的特性之一就是类型安全。
	在运行时，CLR总是知道对象的类型是什么。调用GetType方法即可知道对象的确切类型。
	
	CLR允许将对象转换为它的（实际）类型或它的任何基类型。
	C#不要求任何特殊语法即可将对象转换为它的任何基类型，因为向基类型的转换被认为是一种安全的隐式转换。
	然后，将对象转换为它的某个派生类型时，C#要求开发人员只能进行显示转换，因为这种转换可能在运行时失败。

	类型伪装是许多安全漏洞的根源，它还会破坏应用程序的稳定性和健壮性。

	使用C#的is和as操作符来转型
	is操作符检查对象是否兼容于指定类型，返回Boolean值true或false。
	is操作符永远不抛出异常。特别地，如果对象引用null，is操作符总是返回false，因为没有可检查其类型的对象。
	is操作符通常像下面这样使用：
		if(o is Employee){
			Employee e=(Employee)o;
			//……
		}
	上述代码中，CLR实际检查2次对象类型。
	is操作符首先核实o是否兼容于Employee类型。如果是，在if语句内部转型时，CLR再次核实o是否引用一个Employee。
	CLR的类型检查增强了安全性，但无疑对性能造成了一定影响。
	这是因为CLR首先必须判断变量（o）引用的对象的实际类型，然后CLR必须遍历继承层次结构，用每个基类型去核对指定的类型（Employee）
	as操作符（改进is的处理方式）
		Employee e=o as Employee;
		if(e!=null){
			//……
		}
	在这段代码中，CLR核实o是否兼容于Employee类型：如果是，as返回对同一个对象的非null引用；
												  如果否，as返回null。
	as操作符使CLR只校验一次对象类型，if语句只检查e是否为null，这个检查的速度比校验对象快得多。
	as操作符的工作方式与强制类型转换一样，只是它永远不抛出异常！
	如果对象不能转型，结构就是null。
	所以，正确的做法是检查最终生成的引用是否为null。
	如果企图直接使用最终生成的引用，可能抛出System.NullReferenceException异常。
	注意：C#允许类型定义转换操作符方法。
		  (只有在使用转型表达式时才调用这些方法；使用C#的as或is操作符时永远不调用它们。)

4.3	命名空间和程序集
	命名空间对相关的类型进行逻辑分组，开发人员可通过命名空间方便地定位类型。
	using指令指示编译器尝试为名称附加不同的前缀，直至找到匹配的类型。（可选的，如果愿意，完全可以输入类型的完全限定名称）
	using指令的另一种形式：允许为类型或命名空间创建别名。
	如果只想使用命名空间中的少量类型，不想它的所有类型都跑出来“污染”全局命名空间，别名就显得十分方便。
	另外，如果有两家公司：Australian Boomerang Company和Alaskan Boat Corporaation都创建了名为BuyProduct的类型，且命名空间为ABC。
	C#编译器提供了外部别名（extern alias）的功能，能解决这种问题。外部别名还允许从同一个程序集的两个（或更多）不同的版本中访问同一个类型。
	对于编译器，命名空间的作用就是为类型名称附加以句点分隔的符号，使名称变得更长，更可能具有唯一性。
	【提示】：CLR对“命名空间”一无所知。

	编译器需要保证引用的每个类型都确实存在，而且代码以正确方式使用类型――也就是调用确实存在的方法，向方法传递正确数量的实参，保证实参具有正确类型，正确使用方法返回值，等等。
	如果编译器在源代码文件或者引用的任何程序集中找不到具有指定名称的类型，
	就会在类型名称前附加System.IO.前缀，检查这样生成的名称是否与现有类型匹配。
	如果仍然找不到匹配项，就继续为类型名称附加System.Text.前缀。

	检查类型定义时，编译器必须知道要在什么程序集中检查。
	这通过/r[eference]编译器开关实现。
	编译器扫描引用的所有程序集，在其中查找类型定义。
	一旦找到正确的正确的程序集，程序集信息和类型信息就嵌入生成的托管模块的元数据中。
	为了获取程序集信息，必须将定义了被引用类型的程序集传给编译器。
	C#编译器自动在MSCorLib.dll程序集中查找被引用的类型，即使没有显示告诉它这样做。
	MScorLib.dll程序集包含所有核心Framework类库（FCL）类型（如Object、Int32、String等）的定义。

	编译器对待命名空间的方式存在潜在问题：可能两个（或更多）类型在不同命名空间中同名。
	Microsoft强烈建议开发人员为类型定义具有唯一性的名称。

	要在库中设计由第三方使用的类型，应该在专门的命名空间中定义这些类型。
	事实上，为了降低发生冲突的概率，应该使用自己的完整公司名称（而不是字母缩写或其他简称）来作为自己的顶级命名空间。
	在C#中，namespace指令的作用，只是告诉编译器为源代码种出现的每个类型名称附加命名空间名称前缀，让程序员少打一些字。

	命名空间和程序集
	注意：命名空间和程序集（实现类型的文件）不一定相关。
		  特别地，同一个命名空间中的类型可能在不同程序集中实现；
		  同一个程序集也可能包含不同命名空间中的类型。
		  在文档中查找类型时，文档会明确指出，类型所属的命名空间以及实现了该类型的程序集。

4.4	运行时的相互关系

	线程创建时会分配到1MB的栈。栈空间用于向方法传递实参，方法内部定义的局部变量也在栈上。
	栈从高位地址向低位地址构建。

	最简单的方法包含：“序幕”（prologue）代码，在方法开始做工作前对其进行初始化；
					  “尾声”（epilogue）代码，在方法做完工作后对其进行清理，以便返回至调用者。

	栈帧（stack frame）代表当前线程的调用栈中的一个方法调用。执行线程的过程中，进行的每个方法调用都会在调用栈中创建并压入一个栈帧。
	（调用方法时，押入栈帧，称为wind；方法执行完毕，弹出栈帧，称为unwind。）
	调用方法时，栈帧、实参地址、返回地址会先被压入栈，然后是局部变量……

	堆上所有对象都包含两个额外的成员：类型对象指针（type object pointer）
									  同步块索引（sync block index）

