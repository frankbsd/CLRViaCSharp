第五章：基元类型、引用类型和值类型

5.1	编程语言的基元类型
	基元类型（primitive type）：编译器直接支持的数据类型。基元类型直接映射到FCL中存在的类型。如C#中int直接映射到System.Int32类型。

	char	System.Char  16位Unicode字符（char不像在非托管C++中那样代表一个8位置）
	decimal	System.Decimal	128位高精度浮点值，常用于不容许舍入误差的金融计算。
							128位中，1位时符号，
									 96位时值本身（N）
									 8位时比例因子（k）
									 其余位没有使用。
							decimal实际值时正负Nx10的k次方，其中，-28<=k<=0;
	CLR没有知道如何处理Decimal值的IL指令。

	checked或unchecked

5.2	引用类型和值类型
	CLR支持两种类型：引用类型和值类型。

	引用类型总是从托管堆分配，C#的new操作符返回对象内存地址――即面向对象数据的内存地址。
	1、内存必须从托管堆分配
	2、堆上分配的每个对象都有一些额外的成员（类型对象指针、同步块索引），这些成员必须初始化
	3、对象中的其他字节（为字段而设）总是为0
	4、从托管堆分配对象时，可能强制执行一次垃圾回收。

	值类型的实例一般在线程栈上分配。
	所有值类型都称为结构或枚举。

	所有结构都是抽象类型System.ValueType的直接派生类。System.ValueType又直接从System.Object派生。
	所有枚举都是从System.Enum派生，而System.Enum又派生自System.ValueType。

	值类型可以实现一个或多个接口。
	所有值类型都隐式密封，目的是防止将值类型用作其他引用类型或值类型的基类型。

	只有满足以下全部条件，才应将类型声明为值类型：
		1、类型具有基元类型的行为。
			（如果类型没有提供会更改其字段的成员，就说该类型时不可变（immutable）类型。
			  事实上，对于许多值类型，我们都建议将全部字段标记为readonly。）
		2、类型不需要从其他任何类型继承。
		3、类型也不派生出其他类型。
		4、类型的实例较小（16字节或更小）
		5、类型的实例较大（大于16字节），但不作为方法实参传递，也不从方法返回。
			（类型实例大小也应考虑在列，因为实参默认以传值方式传递，造成对值类型实例中的字段进行复制，对性能造成损害。
			  同样的，被定义为返回一个值类型的方法在返回时，实例中的字段会复制到调用者分配的内存中，对性能造成损害。）
	值类型的主要优势是，不作为对象在托管堆上分配。

	值类型和引用类型的一些区别：
		1、值类型对象有两种表示形式：未装箱和已装箱。
		   引用类型总是处于已装箱形式。
		2、值类型从System.ValueType派生。该类型提供了System.Object相同的方法。
		   但，System.ValueType重写了Equals方法，能在两个对象的字段值完全匹配的前提下返回true。
		       System.ValueType还重写了GetHashCode方法。生成哈希码时，这个重写方法所用的算法会将对象的实例字段中的值考虑在内。
														另外这个默认实现存在性能问题。
			所以【定义自己的值类型时“应重写”】Equals和GetHashCode方法，并提供它们的显示实现。
		3、由于不能将值类型作为基类型来定义新的值类型或者引用类型，
		   所以，不能在值类型中引入任何新的虚方法。（换言之，所有方法都不是抽象的，所有方法都隐式密封，不可重写）
		4、引用类型的变量：包含堆中对象的地址
						   创建时默认初始化为null，表明当前不指向有效对象。
						   试图使用null引用类型变量会抛出NullReferenceException异常。
			相反，值类型的变量：总是包含其基础类型的一个值，而且值类型的所有成员都初始化为0.
								永远不可能抛出NullReferencException。
		5、将值类型变量赋值给另一个值类型变量，会执行逐字段的复制。
				所以，值类型变量自成一体，对值类型变量执行执行的操作不可能影响另一个变量的值。
		   将引用类型的变量赋值给另一个引用类型的变量，只复制内存地址。
				基于此，两个或多个引用类型变量能引用堆中同一个对象，所以对一个变量执行的操作可能影响到引用这个对象的其他变量。
		6、由于未装箱的值类型不在堆上分配，一旦定义了该类型的一个实例的方法不再活动，为它们分配的存储就会被释放，而不是等着进行垃圾回收。

	CLR如何控制类型中的字段布局
		为了提高性能，CLR默认按照它认为最好的布局排列类型的字段。
		但是，在类型定义时，针对类型的各个字段，可以告诉CLR是严格按照自己指定的顺序排列，还是按照CLR认为合适的方式重新排列。

		为了告诉CLR应该怎样做，要为自己定义的类或结构应用System.Runtime.InteropService.StructLayoutAttribute特性。
				向该特性构造器传递LayoutKind.Auto，让CLR自动排列字段；
							  传递LayoutKind.Sequential，让CLR保持你的字段布局；
							  传递LayoutKind.Explicit，利用偏移量在内存中显示排列字段

		Microsoft C#编译器默认为引用类型（类）选择LayoutKind.Auto；
							  为值类型（结构）选择LayoutKind.Sequential
		这是因为，C#编译器认为，和非托管代码互操作时，会经常用到结构。为此，字段必须保持程序员定义的顺序；
		然而，假如创建的值类型不与非托管代码互操作，就应该覆盖C#编译器的默认设定。
			   [StructLayout(LayoutKind.Auto)]
				internal struct SomeValueType
				{
					private readonly Byte m_b;
					private readonly Int16 m_x;
				}

		显示指定每个字段的偏移量，示例如下
				[StructLayout(LayoutKind.Explicit)]
				internal struct SomeValueType2
				{
					//指出字段第一个字节距离实例起始处的偏移量（以字节为单位）
					[FieldOffset(0)]
					private readonly Byte m_b;
					[FieldOffset(0)]
					private readonly Int16 m_x;
				}
		显示布局常用于模拟非托管C/C++中的union，因为多个字段可起始于内存的相同便宜位置。
		注意：在类型中，一个引用类型和一个值类型相互重叠是不合法的。
			  多个引用类型在同一个起始偏移位置相互重叠，合法，但无法验证（unverifiable）
			  多个值类型相互重叠，合法。还需使所有重叠字段都必须能通过公共字段访问，才可验证。

5.3	值类型的装箱和拆箱
	将值类型转换成引用类型要使用装箱机制。
	对值类型的实例进行装箱时，要发生的事情有：
		1、在托管堆中分配内存。分配的内存量是【值类型各字段所需的内存量】，
		   还要加上托管堆所有对象都有的【类型对象指针和同步块索引所需的内存量】。
		2、值类型的字段复制到新分配的堆内存。
		3、返回对象地址。（现在该地址是对象引用；值类型成了引用类型）
	C#编译器自动生成对值类型实例进行装箱所需的IL代码。
	注意：FCL现在包含一组新的泛型集合类，应该使用System.Collections.Generic.List<T>类而不是System.Collections.ArrayList类。
		  其最大的改进，就是泛型集合类允许开发人员在操作值类型的集合时不需要对集合中的向进行装箱/拆箱；
						使开发人员获得了编译时的类型安全性，源代码也因为强制类型转换的次数减少而变得更清晰。

	CLR分两步完成复制：
		第一步，获取已装箱Point对象中的各个Point字段的地址；这个过程称为拆箱（unboxing）
		第二步，将字段包含的值从堆复制到基于栈的值类型实例中。